avl:  https://blog.csdn.net/juanqinyang/article/details/51418629
BFS:  https://leetcode.jp/leetcode%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E4%B9%8B%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2bfs%E8%B6%85%E8%AF%A6%E7%BB%86%E7%99%BD%E8%AF%9D%E8%AE%B2%E8%A7%A3/

DFS:  https://leetcode.jp/leetcode%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E4%B9%8B%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2dfs%E8%B6%85%E8%AF%A6%E7%BB%86%E7%99%BD%E8%AF%9D%E8%AE%B2%E8%A7%A3%E4%B8%8A/

heap:  https://blog.csdn.net/juanqinyang/article/details/51418629
sort:  https://zhuanlan.zhihu.com/p/42586566





//快速排序
void quicksort(int arr[], int low, int high){
    qsort(arr, low, high);
}
void qsort(int arr[], int low, int high){
    if(low >= high){
        return;
    }
    int k=partition(arr, low, high);
    qsort(arr, low, k-1);
    qsort(arr, k+1, high);
}

int partition(int arr[], int low, int high){
    int k = arr[low];
    while(low < high){
        while(low<high && arr[high]>=k)--high;
        arr[low]=arr[high];
        while(low<high && arr[low]<=k)++low;
        arr[high]=arr[low];
    }
    arr[low]=k;
    return low;
}
